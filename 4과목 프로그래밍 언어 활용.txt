# 2장 프로그래밍 언어 활용

[데이터 타입]

C/C++의 데이터 타입 크기 및 기억 범위
정수 int - 4Byte

JAVA의 데이터 타입 크기 및 기억 범위
정수 long - 8Byte

Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type) : 문자열처럼 값이 연속적으로 이어진 자료형
리스트(List) : 다양한 자료형의 값을 연속적으로 저장하며, 필요에 따라 개수를 늘리거나 줄일 수 있음
튜플(Tuple) : 리스트처럼 요소를 연속적으로 저장하지만, 요소의 추가, 삭제, 변경은 불가능
 
[변수]

변수명 작성 규칙
- 영문자, 숫자, _(under bar)를 사용할 수 있다.
- 첫 글자는 영문자나 _(under bar)로 시작해야 하며, 숫자는 올 수 없다.
- 글자 수에 제한이 없다.
- 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없다.
- 대, 소문자를 구분한다.
- 예약어를 변수명으로 사용할 수 없다.
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 한다.
- 변수 선언 시 변수명에 데이터 타입을 명시하는 것을 헝가리안 표기법(Hungarian Natation)이라고 한다.

[연산자]

산술 연산자
++, -- 
전치 : 변수 앞에 증감 연산자가 오는 형태로 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용한다.
후치 : 변수 뒤에 증감 연산자가 오는 형태로 먼저 변수를 연산에 사용한 후 변수의 값을 증감시킨다.

비트 연산자
비트별(0, 1)로 연산하여 결과를 얻는 연산자이다.
- &(and) : 모든 비트가 1일 때만 1
- ^(xor) : 모든 비트가 같으면 0, 하나라도 다르면 1
- |(or) : 모든 비트 중 한 비트라도 1이면 1
- ~(not) : 각 비트의 부정, 0이면 1, 1이면 0
- <<(왼쪽 시프트) : 비트를 왼쪽으로 이동
- >>(오른쪽 시프트) : 비트를 오른쪽으로 이동

논리 연산자
두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과호 얻는 연산자이다.
- !(not) : 부정
- &&(and) : 모두 참이면 참
- ||(or) : 하나라도 참이면 참

조건 연산자
- 조건 ? 수식1 : 수식2; '조건'의 수식이 참이면 '수식1'을, 거짓이면 '수식2'를 실행한다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 3장 응용 SW 기초 기술 활용

[UNIX / LINUX / MacOS]

UNIX의 개요 및 특징
- 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제인다.
- 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.
- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System)이다.
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.

커널(Kernel)
- UNIX의 가장 핵심적인 부분이다.
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다.
- 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행한다.

쉘(Shell)
- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
- 시스템과 사용자 간의 인터페이스를 담당한다.

[기억장치 관리의 개요]

배치(Placement) 전략
새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬것인지를 결정하는 전략이다.
- 최초 적합(First Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
- 최적 적합(Best Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
- 최악 적합(Worst Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

[가상기억장치 구현 기법 / 페이지 교체 알고리즘]

페이징(Paging) 기법
가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.
- 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라고 한다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다.

세그먼테이션(Segmentation) 기법
가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법이다.
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.
- 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요하다.

페이지 교체 알고리즘
페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.
- OPT(OPTimal replacement, 최적 교체) : 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다. 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.
- FIFO(First In First Out) : 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다.
- LRU(Least Recintly Used) : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다. 
- LFU(Least Frequently Used : 사용 빈도가 가장 적은 페이지를 교체하는 기법이다.
- NUR(Not Used Recently) : 최근에 사용하지 않은 페이지를 교체하는 기법이다.

[프로세스의 개요]

프로세스 상태 전이
- 제출(Submit) : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태이다.
- 접수(Hold) : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태이다.
- 준비(Ready) : 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태이다.
- 실행(Run) : 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태이다.
- 대기(Wait) : 프로세스에 입출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태이다.
- 종료(Exit) : 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태이다.

[주요 스케줄링 알고리즘]

FCFS(First come First Service, 선입 선출) = FIFO(First In First Out)
P1 : 20, P2 : 4, P3 : 6
평균 실행 시간 : (20+4+6)/3 = 10
평균 대기 시간 : (0+20+24)/3 = 14.6
평균 반환 시간 : (20+24+30)/3 = 24.6

SJF(Shortest Job First, 단기 작업 우선)
제출 시간이 없을 경우
P1 : 20, P2 : 4, P3 : 6
평균 실행 시간 : (4+6+20)/3 = 10
평균 대기 시간 : (0+4+10)/3 = 4.6
평균 반환 시간 : (4+10+30)/3 = 14.6

제출 시간이 있을 경우
P1 : 20, P2 : 4, P3 : 6
평균 실행 시간 : (20+4+7)/3 = 10.3
평균 대기 시간 : (0+18+23)/3 = 13.6
평균 반환 시간 : (20+22+30)/3 = 24

HRN(Hightest Response-radio Next)
우선순위 계산식 = (대기 시간+ 서비스 시간) / 서비스시간

[인터넷]

IP주소(Internet Protocol Address)
인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.
- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.
- 네트워크 부분의 길이에 따라 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.

서브네팅(Subnetting)
할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.
- 서브넷 마스크는 각 클래스마다 다르게 사용된다.
ex) 192.168.1.0/24 네트워크를 FLSM 방식을 이요하여 3개의 Subnet으로 나누시오. (단 IP Subnet-Zero를 적용했다.)
192.168.1.0/24 네트워크의 서브넷 마스크는 1의 개수가 24개, 즉 C 클래스에 속하는 네트워크이다.
11111111 | 11111111 | 11111111 | 00000000
  255         255        255         0
서브넷 마스크를 Subnet으로 나눌 때는 서브넷 마스크가 0인 부분, 즉 마지막 8비트를 이용함녀 된다.
Subnet으로 나눌 때 "3개의 Subnet으로 나눈다."는 것처럼 네트워크가 기준일 때는 왼쪽을 기준으로 나눌 네트워크 수에 필요한 비트를 할당하고 나머지 비트로 호스트를 구성하면 된다.
3개의 Subnet으로 구성하라 했으니 8비트 중 3을 표현하는데 필요한 2비트를 제외하고 나머지 6비트를 호스트로 구성하면 된다.
                               | 네트워크 ID | 호스트 ID
11111111 | 11111111 | 11111111 |     00     | 000000
  255         255        255               192
호스트 ID가 6Bit로 설정되었고, 문제에서 FLSM(Fixed Length Subnet Mask), 즉 고정된 크기로 주소를 할당하라고 했으므로 3개의 네트워크에 64개(2^6 = 64)씩 고정된 크기로 할당하면 다음과 같습니다.
네트워크(ID) | 호스트 수 |             IP 주소 범위
   1(00)    |    64    | 192.168.1.0(00000000) ~ 63(00111111)
   2(01)    |    64    | 192.168.1.64(01000000) ~ 127(01111111)
   3(10)    |    64    | 192.168.1.128(10000000) ~ 191(10111111)

IPv6(Internet Protocol version 6)의 개요
현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.
- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv4에 비해 자료 전송 속도가 빠르다.

[OSI 참조모델]

OSI참조 모델에서의 데이터 단위
- 물리 계층 : 비트
- 데이터 링크 계층 : 프레임
- 네트워크 계층 : 패킷
- 전송 계층 : 세그먼트
- 세션, 표현, 응용 계층 : 메시지

물리 계층(Physical Layer) : 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다.
  - 관련 장비 : 리피터, 허브

데이터 링크 계층(Data Link Layer) : 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당한다.
  - 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능을 한다.
  - 관련 장비 : 브리지, 스위치

네트워크 계층(Network Layer) : 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 한다.
  - 네트워크 연결을 설정, 유지, 해제하는 기능을 한다.
  - 발신지와 목적지의 논리 주소가 추가된 패킷을 최종 목적지까지 전달하는 책임을 진다.
  - 관련 장비 : 라우터

전송 계층(Transpot Layer) : 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 한다.
  - 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행한다.
  - TCP, UDP 등의 표준이 있다.
  - 관련 장비 : 게이트웨이

세션 계층(Session Layer) : 송수신 측 간의 관련성을 유지하고 대화 제어를 담당한다.

표현 계층(Presentation Layer) : 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 한다.

응용 계층(Application Layer) : 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공한다.

[TCP/IP]

응용 계층의 주요 프로토콜
MQTT(Message Queuing Telemetry Transport) : 발행-구독 기반의 메시징 프로토콜로, IoT 환경에서 자주 사용된다.

전송 계층의 주요 프로토콜
TCP(Transmission Control Protocol)
- 양방향 연결(Full Duplex Connection)형 서비스를 제공한다.
- 가상 회선 연결(Virtual Circuit Connection) 형태의 서비스를 제공한다.
- 순서 제어, 오류 제어, 흐름 제어 기능을 한다.
- 

























