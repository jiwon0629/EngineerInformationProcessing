# 1장 요구사항 확인

[소프트웨어 생명 주기]

폭포수 모형(Waterfall Model)
 - 소프트웨어 개발 과정의 한 단계가 끝나지만 다음 단계로 넘어갈 수 있는 선형 순차적 모형이다

프로토타입 모형(Prototype Model)
 - 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측하는 모형이다.

나선형 모형(Spiral Model)
 - 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것

애자일 모형(Agile Model)
 - 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론

[XP(eXtreme Programming)]

Refactoring : 프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템을 재구성합니다.

[요구사항의 유형]

기능 요구사항(Functional requirements) : 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
비기능 요구사항(Non - functional requirements) : 품질이나 제약사향과 관련이 있다.

[UML(Unified Modeling Language)]

UML은 시스템 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지행 모델링 언어이다.

연관 관계는 2개 이상의 사물이 서로 관련되어 있음을 표현한다.
집합 관계는 하나의 사물이 다른 사물이 포함되어 있는 관계를 표현한다.
포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현한다.
일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다.
의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현한다.
실체화 관계는 사물이 할 수 있거나 해야 하는 기능(오퍼레이션, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다.

다이어그램(Diagram)

구조적(Structural) 다이어그램의 종류
- 클래스 다이어그램(Class Diagram) : 클래스 사이의 관계를 표현한다.
- 객체 다이어그램(Object Diagram) : 객체와 객체 사이의 관계로 표현한다.
- 컴포넌트 다이어그램(Component Diagram) : 컴포넌트 간의 인터페이스를 표현한다.
- 배치 다이어그램(Deployment Diagram) : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다.
- 패키지 다이어그램(Pakage Diagram) : 그룹화한 패키지들의 관계를 표현한다.

행위(Behavioral) 다이어그램의 종류
- 유스케이스 다이어그램(Use Case Diagram) : 사용자의 요구를 분석하는 것
- 순차 다이어그램(Sequence Diagram) : 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현한다.
- 상태 다이어그램(State Diagram) : 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용된다.
- 활동 다이어그램(Activity Diagram) : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 2장 화면 설계

[사용자 인터페이스]

사용자 인터페이스의 구분
- CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
- GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- VUI(Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스

사용자 인터페이스의 기본 원칙
- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다.
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

사용자 인터페이스의 설계 지침
- 사용성 : 사용자가 소프트웨어를 얼마나 빠르고 쉽게 이해할 수 있는지, 얼마나 편리하고 효율적으로 사용할 수 있는지를 말하는 것

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 3장 애플리케이션 설계

[객체지향(Object-Oriented)]

객체(Object) : 객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈이다.
클래스(Class) : 공통된 속성과 연산(행위)을 갖는 객체의 집합
캡슐화(Encapsulation) : 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.
상속(Inheritance) : 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것이다.
다형성(Polymorphism) : 메시지에 의해 객체(클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각가의 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미한다.

[객체지향 분석 및 설계]

객체지향 분석의 방법론
- Rumbaugh(럼바우) 방법 : 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법이다.
  객체 모델링 기법(OMT, Object-Modeling Technique)이라고 불린다.
  분석 활동은 '객체 모델링 -> 동적 모델링 -> 기능 모델링' 순으로 이루어진다.

객체지향 설계 원칙
- 단일 책임 원칙(SRP, Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다는 원칙. 응집도는 높고, 결합도는 낮게 설계한느 것을 의미한다.
- 개방-폐쇄 원칙(OCP, Open-Closed Principle) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle) : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙
- 의존 역전 원칙(DIP, Dependency Inversion Principle) : 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙

[모듈]

모듈은 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다.
모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다.

결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다.
결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.

자료 결합도 | 스탬프 결합도 | 제어 결합도 | 외부 결합도 | 공통 결합도 | 내용 결합도 
결합도 약함 <-----------------------------------------------------> 결합도 강함

자료 결합도(Data Coupling) : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도이다.
스탬프 결합도(Stamp Coupling) : 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도이다.
제어 결합도(Control Coupling) : 어떤 모듈이 다른 모듈의 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달하는 결합도이다.
외부 결합도(External Coupling) : 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도이다.
공통(공유) 결합도(Common Coupling) : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도이다.
내용 결합도(Contnet Coupling) : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도이다.

응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다.
다양한 기준으로 모듈을 구성할 수 있으나 응집도가 강할수록 품직이 높고, 약할수록 품질이 낮다.

우연적 응집도 | 논리적 응집도 | 시간적 응집도 | 절차적 응집도 | 교환적 응집도 | 순차적 응집도 | 기능적 응집도
응집도 약함 <-----------------------------------------------------------------------------> 응집도 강함

우연적 응집도(Coincidental Cohesion) : 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도
논리적 응집도(Logical Cohesion) : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
시간적 응집도(Temporal Cohesion) : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
절차적 응집도(Procedural Cohesion) : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
교환(통신)적 응집도(Communication Cohesion) : 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
순차적 응집도(Sequential Cohesion) : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도

[디자인 패턴]

디자인 패턴(Design Pattern)의 개요
각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.

생성 패턴(Creational Pattern)
추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
빌더(Builder) : 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성한다.
팩토리 메소드(Factory Method) : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴, 가상 생성자(Virtual Constructor) 패턴이라고도 한다.
프로토타입(Prototype) : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
싱글톤(Singleton) : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.

구조 패턴(Structural Pattern)
어댑터(Adapter) : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.
브리지(Bridge) : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴이다.
컴포지트(Composite) : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴이다.
데코레이터(Decorator) : 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다.
퍼싸드(Facade) : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다.
플라이웨이트(Flyweight) : 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다.
프록시(Proxy) : 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴이다.

행위 패턴(Behavioral Pattern)
책임 연쇄(Chain of Responsibility) : 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다.
커맨드(Command) : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.
인터프리터(Interpreter) : 언어에 문법 표현을 정의하는 패턴이다.
반복자(Iterator) : 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.
중재자(Mediator) : 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴이다.
메멘토(Memento) : 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴이다.
옵서버(Observer) : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴, 주로 분산된 시스템 간에 이벤트를 생성, 발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다.
상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴이다.
전략(Stategy) : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.
템플릿 메소드(Template Method) : 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.
방문자(Visitor) : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# 4장 인터페이스 설계

[인터페이스 요구사항 검증]

요구사항 검증방법
동료검토(Peer Review) : 요구사항 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법이다.
워크스루(Walk Through) : 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법이다.
인스펙션(Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법이다.

[미들웨어 솔루션 명세]

미들웨어(Middleware)의 개념
분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나 프로토콜, 통신 환경 등을 연결하여 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 원만한 통신이 이루어지도록 다양한 서비스를 제공한다.
DB(DataBase) : 원격의 데이터베이스와 연결하기 위한 미들웨어이다.
RPC(Remote Procedure Call) : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컴 프로시저처럼 호출하는 방식의 미들웨어이다.
MOM(Message Oriented Middleware) : 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
TP-Monitor(Transaction Processing Monitor) : 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어이다.
ORB(Object Request Broker) :  객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어이다.
WAS(Web Application Server) : 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.





































